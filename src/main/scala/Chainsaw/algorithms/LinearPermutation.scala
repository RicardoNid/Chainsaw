package Chainsaw.algorithms

import LinearPermutation.{gf2ToInt, int2GF2}
import spinal.core.log2Up
import Chainsaw._
import Chisel.isPow2

import scala.collection.mutable.ArrayBuffer

/** A class representing a linear permutation.
  *
  * Linear permutations, defined in the reference below are permutations that can be represented by a bit matrix, the
  * binary representation of the output index is the product of the product of this matrix and the binary representation
  * of the input index
  *
  * Linear permutations can be implemented with lower cost than general permutations, and are widely used in transforms
  * and sorting networks.
  *
  * @param bitMatrix
  *   the bit matrix representing the linear permutation
  * @tparam T
  *   the type of elements being permuted
  * @see
  *   ''Puschel, Markus et al. “Permuting streaming data using RAMs.” J. ACM 56 (2009): 10:1-10:34.''
  */
class LinearPermutation[T](val bitMatrix: Matrix[GF2])
    extends Permutation[T](LinearPermutation.bitMatrix2Permutation(bitMatrix)) {

  require(bitMatrix.isSquare)
  val n = bitMatrix.rowCount

  ////////////////////
  // Following methods implement the algorithm described in the paper to generate circuits for linear permutations, to get the solution, call solve(k), where 2^k is the number of ports
  ////////////////////
  private def getPartitions(matrix: Matrix[GF2], k: Int) = {
    val m4 = matrix.subMatrix(0 until (n - k), 0 until (n - k))
    val m3 = matrix.subMatrix(0 until (n - k), (n - k) until n)
    val m2 = matrix.subMatrix((n - k) until n, 0 until (n - k))
    val m1 = matrix.subMatrix((n - k) until n, (n - k) until n)
    (m1, m2, m3, m4)
  }

  private def getConnectionNetwork(m1: Matrix[GF2], m2: Matrix[GF2], k: Int) = {
    def getTs(matrix: Matrix[GF2]): Array[Matrix[GF2]] = {
      val (l, u) = matrix.getLU
      val n      = matrix.rowCount
      require(l.isInvertible, "bad gaussian elimination")
      val TPrimes: Array[Matrix[GF2]] = u.data.zipWithIndex
        .filter { case (row, i) => row.exists(_ != GF2(0)) } // non-zero rows
        .map { case (row, i) =>
          val value = (0 until n).map(j => if (j == i) row else Array.fill(row.length)(GF2(0))).toArray
          Matrix(value)
        }
      //    println(s"size of l: ${l.rowCount} X ${l.colCount}, size of u: ${u.rowCount} X ${u.colCount}, size of T: ${TPrimes.head.rowCount} X ${TPrimes.head.colCount}")
      val Ts = TPrimes.map(l * _)
      require(Ts.length == matrix.getRank)
      require(Ts.forall(_.getRank == 1), "bad Ts")
      require(matrix == Ts.reduce(_ + _))
      Ts
    }
    val enum = Array(GF2(0), GF2(1))
    val mTs  = getTs(m2) // m2 = T1 + T2 * ... * Ts
    val connectionSets = mTs.reverse.zipWithIndex.map { case (t, i) =>
      val x2 = (k until n).reverse.map(i => s"x_$i").toArray
      // control bit given by T_i * x_2, where x_2 is the vector generated by the counter
      val controlExpression =
        t.data.flatMap(row => row.zip(x2).filter { case (gf, _) => gf != GF2(0) }.map(_._2)).mkString(" + ")

      val imageIn     = if (i == 0) (m1.getInverse * t).getImage(enum) else t.getImage(enum)
      val imageOut    = t.getImage(enum)
      val multipleOut = if (i == 0) m1 else Matrix.identity[GF2](k)
      val connectionStringSet = (0 until 1 << k)
        .map { i =>
          val indexVector = Matrix.column(int2GF2(i, k): _*)
          // TODO: order of indices inside a set?
          val inputSet = imageIn.map(v => v + indexVector).map(_.data.flatten.toSeq).map(gf2ToInt).sorted
          val outputSet =
            imageOut.map(v => v + multipleOut * indexVector).map(_.data.flatten.toSeq).map(gf2ToInt).sorted
          val connectionDescription = // for a proper "distinct" operation
            inputSet.mkString(" ") + " -> " + outputSet.mkString(" ") // I/O indices of a 2X2 switch
          connectionDescription
        }
        .distinct
        .sortBy(_.split(" ")(3).toInt)
      val connectionSet =
        connectionStringSet.map(_.split(" ")).map(arr => arr.take(2) ++ arr.takeRight(2)).map(arr => arr.map(_.toInt))

      (connectionSet, controlExpression)
    }
    connectionSets
  }

  private def getAddress(m3: Matrix[GF2], m4: Matrix[GF2], k: Int) = {
    val x1      = (0 until k).reverse.map(i => s"x_$i").toArray
    val x2      = (k until n).reverse.map(i => s"x_$i").toArray
    val a       = m4.data.map(row => row.zip(x2).filter { case (gf, _) => gf != GF2(0) }.map(_._2))
    val b       = m3.data.map(row => row.zip(x1).filter { case (gf, _) => gf != GF2(0) }.map(_._2))
    val address = a.zip(b).map { case (a, b) => (a ++ b).mkString(" + ") }
    address.mkString(",")
  }

  def solve(k: Int) = {
    // step 1: get M for writing stage and N for reading stage
    val (matrixN, matrixM) = getDecomposition(k)
//    println(s"matrixM: \n$matrixM\nmatrixN: \n$matrixN\nbitMatrix: \n${matrixN.getInverse * matrixM}")
    val (m1, m2, m3, m4) = getPartitions(matrixM, k)
    val (n1, n2, n3, n4) = getPartitions(matrixN, k)
    require(n4.isIdentity && n3.isZero, s"bad read address\nn4: ${n4}\nn3: ${n3}")
    // step 2: decompose M2 and N2 to get connecting network
    val connM = getConnectionNetwork(m1, m2, k)
    val connN = getConnectionNetwork(n1, n2, k)
    // step 3: get write and read address for each port
    val readAddress  = getAddress(n3, n4, k)
    val writeAddress = getAddress(m3, m4, k)

    // print the result
    println(s"Solution of linear permutation streamed with 2^$k = ${1 << k} ports")
    println(s"bit matrix: \n$bitMatrix")

    println("writing network")
    connM.zipWithIndex.foreach { case ((connectionSet, controlExpression), i) =>
      println(s"stage $i controlled by $controlExpression")
      connectionSet.foreach { case Array(i, j, x, y) => println(s"$i $j <-> $x $y") }
    }
    println("reading network")
    connN.zipWithIndex.foreach { case ((connectionSet, controlExpression), i) =>
      println(s"stage $i controlled by ${controlExpression.replace("x", "y")}")
      connectionSet.foreach { case Array(i, j, x, y) => println(s"$i $j <-> $x $y") }
    }
    println(s"write address: $writeAddress, read address: ${readAddress.replace("x", "y")}")
    // TODO: build the circuit according to the solution and verify it
    (n, k, connM, connN, writeAddress, readAddress)
  }

  def getDecomposition(k: Int): (Matrix[GF2], Matrix[GF2]) = {
    val (p1, p2, p3, p4) = getPartitions(bitMatrix, k)
    if (bitMatrix.isPermutationMatrix) {
      val rowIndices  = (0 until p1.rowCount).filter(i => p1.data(i).forall(_ == GF2(0))) // all-zero rows of P1
      val colIndices  = (0 until p3.rowCount).filter(i => p3.data(i).exists(_ != GF2(0))) // non-zero rows of P3
      val coordinates = rowIndices.zip(colIndices)
      val values: Array[Array[GF2]] = Array.tabulate(n, n)((i, j) => {
        if (i == j) GF2(1)                                      // diagonal
        else if (coordinates.contains((i - (n - k), j))) GF2(1) // fill H2 with coordinates
        else GF2(0)
      })
      val H = Matrix(values)
      val N = H.getInverse
      val M = H * bitMatrix
      require(N.getInverse * M == bitMatrix)
      (N, M)
    } else {
      ??? // TODO: the general case
    }
  }

  def toPermutation: Permutation[T] = Permutation[T](permuted)

  def getInverse = LinearPermutation[T](bitMatrix.getInverse)

  override def toString: String = {
    def int2String(i: Int): String = i.toBinaryString.padToLeft(bitMatrix.rowCount, '0')
    "permutation: \n" + (0 until sizeIn).map(i => s"${int2String(i)} -> ${int2String(permuted(i))}").mkString("\n")
  }

  override def symbol: String = s"LP($sizeIn)"

}
object LinearPermutation {

  def apply[T](bitMatrix: Matrix[GF2]): LinearPermutation[T] = new LinearPermutation(bitMatrix)

  def int2GF2(i: Int, size: Int): Seq[GF2] = i.toBinaryString.padToLeft(size, '0').map(_.toInt).map(GF2(_))

  def gf2ToInt(seq: Seq[GF2]): Int = Integer.parseInt(seq.mkString, 2)

  def bitMatrix2Permutation(bitMatrix: Matrix[GF2]): Seq[Int] = {
    val permuted = Array.fill(1 << bitMatrix.rowCount)(0)
    (0 until 1 << bitMatrix.rowCount).foreach { indexIn =>
      val columnIn: Matrix[GF2]  = Matrix.column(int2GF2(indexIn, bitMatrix.rowCount): _*)
      val columnOut: Matrix[GF2] = bitMatrix * columnIn
      permuted.update(gf2ToInt(columnOut.data.flatten.toSeq), indexIn) // indexOut
    }
    permuted
  }

  def identity[T](n: Int) = {
    val identity = Matrix(Array.tabulate(n, n)((i, j) => GF2(i == j)))
    new LinearPermutation[T](identity)
  }

  def bitReversal[T](n: Int): LinearPermutation[T] = {
    val bitReversal = Matrix(Array.tabulate(n, n)((i, j) => GF2(i + j == n - 1)))
    new LinearPermutation[T](bitReversal)
  }

  def perfectShuffle[T](n: Int): LinearPermutation[T] = {
    val perfectShuffle = Matrix(Array.tabulate(n, n)((i, j) => GF2(j == ((i + 1) % n))))
    new LinearPermutation[T](perfectShuffle)
  }

  /** create the stride permutation of given size and stride.
    *
    * @param n
    *   The size of the permutation is 2^n^
    * @param r
    *   The stride length is 2^r^
    * @return
    *   A LinearPermutation object representing the stride permutation.
    */
  def stridePermutation[T](n: Int, r: Int): LinearPermutation[T] = {
    if (r == 0) identity(n)
    else {
      val stridePermutation = Seq.fill(r)(perfectShuffle(n).bitMatrix).reduce(_ * _)
      new LinearPermutation[T](stridePermutation)
    }
  }

  def sp[T](size: Int, stride: Int): LinearPermutation[T] = LinearPermutation.stridePermutation[T](log2Up(size), log2Up(size / stride))


  def fromPermutation[T](permutation: Permutation[T]): Option[LinearPermutation[T]] = {
    val isBase2 = isPow2(permutation.sizeIn)
    if (!isBase2) None
    else { // build a linear system of the bit matrix coefficients(according to I/O index) and solve it
      val n         = log2Up(permutation.sizeIn)
      val equations = ArrayBuffer[Array[GF2]]()
      val target    = ArrayBuffer[GF2]()
      (0 until permutation.sizeIn).foreach { i =>
        val indexIn   = i
        val indexOut  = permutation.permuted.indexOf(i)
        val columnIn  = Matrix.column(int2GF2(indexIn, n): _*)
        val columnOut = Matrix.column(int2GF2(indexOut, n): _*)
        (0 until n).foreach { j =>
          target += columnOut.data.flatten.apply(j)
          val coeffs = j * n until (j + 1) * n
          val equation = (0 until n * n).map { k =>
            if (coeffs.contains(k) && columnIn.data.flatten.apply(k - j * n) == GF2(1)) GF2(1)
            else GF2(0)
          }
          equations += equation.toArray
        }
      }
      val m = Matrix(equations.toArray)
      val ret = m
        .solve(Matrix.column(target: _*))
        .map(column => Matrix(column.data.flatten.grouped(n).toArray)) // column vector -> n X n matrix
        .map(LinearPermutation[T])                                     // matrix -> linear permutation
      ret
    }
  }

}